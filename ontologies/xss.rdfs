<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE rdf:RDF [
	 <!ENTITY rdf 'http://www.w3.org/1999/02/22-rdf-syntax-ns#'>
	 <!ENTITY xss 'http://freedesktop.org/standards/xesam/1.0/schema#'>
	 <!ENTITY rdfs 'http://www.w3.org/2000/01/rdf-schema#'>
]>
<rdf:RDF xmlns:rdf="&rdf;"
	 xmlns:xss="&xss;"
	 xmlns:rdfs="&rdfs;">


<rdf:Property rdf:about="&xss;alias">
	<rdfs:label>xss:alias</rdfs:label>
	<rdfs:domain rdf:resource="&rdf:Property"/>
	<rdfs:comment>Alias for user query language. Example: "tag" for xesam:userKeyword</rdfs:comment>
</rdf:Property>

<rdf:Property rdf:about="&xss;minCardinality">
	<rdfs:label>xss:minCardinality</rdfs:label>
	<rdfs:domain rdf:resource="&rdf:Property"/>
	<rdfs:comment>Minimal Cardinality. The minimal number of properties of this type that must be set for classes to which this property applies. Could be used to specify mandatory properties</rdfs:comment>
</rdf:Property>

<rdf:Property rdf:about="&xss;maxCardinality">
	<rdfs:label>xss:maxCardinality</rdfs:label>
	<rdfs:domain rdf:resource="&rdf:Property"/>
	<rdfs:comment>Maximal Cardinality. The maximal number of properties of this type that may be set for classes to which this property applies.</rdfs:comment>
</rdf:Property>

<rdf:Property rdf:about="&xss;isIndexed">
	<rdfs:label>xss:isIndexed</rdfs:label>
	<rdfs:domain rdf:resource="&rdf:Property"/>
	<rdfs:comment>Is property indexed</rdfs:comment>
</rdf:Property>

<rdf:Property rdf:about="&xss;isTokenized">
	<rdfs:label>xss:isTokenized</rdfs:label>
	<rdfs:domain rdf:resource="&rdf:Property"/>
	<rdfs:comment>Is property tokenized. Tokenizing is a process of splitting a property value into parts which are roughtly an equivalent of words in a text. Tokenizing rules however may differ depending on field, and could for example be used to split complex IDs into smaller parts. Example: software-version ID like "linux-2.6.20" can be split into software and version parts so that efficient searches for both could be performed. No tokenization means the whole field value is treated as a single token/word</rdfs:comment>
</rdf:Property>

<rdf:Property rdf:about="&xss;relevance">
	<rdfs:label>xss:relevance</rdfs:label>
	<rdfs:domain rdf:resource="&rdf:Property"/>
	<rdfs:comment>Defines how relevance rating of the file is affected if a match is found in this field</rdfs:comment>
</rdf:Property>

<rdf:Property rdf:about="&xss;inverseProperty">
	<rdfs:label>xss:inverseProperty</rdfs:label>
	<rdfs:domain rdf:resource="&rdf:Property"/>
	<rdfs:range rdf:resource="&rdf:Property"/>
	<rdfs:comment>A inverseProperty B: if (C A D), then (D B C). need better comment :)</rdfs:comment>
</rdf:Property>






<rdfs:Class rdf:about="&xss;Uri">
	<rdfs:label>xss:Uri</rdfs:label>
	<rdfs:comment>URI data type. URIs should be used to link to all objects which can't be represented as a basic type(string,int,date etc). Example: album art, program icon. URI may or may not be accessible via VFS.</rdfs:comment>
</rdfs:Class>

<rdfs:Class rdf:about="&xss;Url">
	<rdfs:subClassOf rdf:resource="&xss;Uri"/>
	<rdfs:label>xss:Url</rdfs:label>
	<rdfs:comment>URL data type. URL unlike URI is usually directly accessible through the VFS of your choice. data:// urls could be used to encode binary objects.</rdfs:comment>
</rdfs:Class>

<rdfs:Class rdf:about="&xss;DateTime">
	<rdfs:label>xss:DateTime</rdfs:label>
	<rdfs:comment>DateTime data type</rdfs:comment>
</rdfs:Class>

<rdfs:Class rdf:about="&xss;Int">
	<rdfs:label>xss:Int</rdfs:label>
	<rdfs:comment>Integer data type</rdfs:comment>
</rdfs:Class>

<rdfs:Class rdf:about="&xss;Float">
	<rdfs:label>xss:Float</rdfs:label>
	<rdfs:comment>Floating point data type</rdfs:comment>
</rdfs:Class>

<rdfs:Class rdf:about="&xss;String">
	<rdfs:label>xss:String</rdfs:label>
	<rdfs:comment>String data type</rdfs:comment>
</rdfs:Class>

<rdfs:Class rdf:about="&xss;Bool">
	<rdfs:label>xss:Bool</rdfs:label>
	<rdfs:comment>Boolean data type</rdfs:comment>
</rdfs:Class>

</rdf:RDF>